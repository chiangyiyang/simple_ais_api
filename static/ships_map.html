<!DOCTYPE html>
<html lang="zh-tw">

<head>
    <meta charset="UTF-8">
    <title>船舶位置地圖</title>
    <!-- Include the CesiumJS JavaScript and CSS files -->
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.126/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.126/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        html,
        body,
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="cesiumContainer"></div>
    <script>
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJiYWU1ZDY3ZC1mYzM1LTQwMTUtYWEwMy1hZjBlZjdlNmRmZTUiLCJpZCI6MjQ5ODg1LCJpYXQiOjE3Mjk1ODExNjJ9.PMxlzgfO9AnBGlodb-qOO8DFhUMOFc3QMbfFqVKk7xY';

        // 初始化 Cesium Viewer
        const viewer = new Cesium.Viewer('cesiumContainer', {
            terrain: Cesium.Terrain.fromWorldTerrain(),
        });

        function getArrowPolyline(longitude, latitude, heading, length) {
            // console.log(heading);
            // Convert heading to radians and calculate the base position
            const headingRad = Cesium.Math.toRadians(90-heading);
            const baseLength = (1 / 7) * length;

            const baseLongitude = longitude - (baseLength * Math.cos(headingRad)) / (111320 * Math.cos(Cesium.Math.toRadians(latitude)));
            const baseLatitude = latitude - (baseLength * Math.sin(headingRad)) / 110540;

            // Calculate the coordinates for the arrow wings
            const angle = 165;
            const leftWingLongitude = longitude + (length * 0.2 * Math.cos(headingRad + Cesium.Math.toRadians(angle))) / (111320 * Math.cos(Cesium.Math.toRadians(latitude)));
            const leftWingLatitude = latitude + (length * 0.2 * Math.sin(headingRad + Cesium.Math.toRadians(angle))) / 110540;

            const rightWingLongitude = longitude + (length * 0.2 * Math.cos(headingRad - Cesium.Math.toRadians(angle))) / (111320 * Math.cos(Cesium.Math.toRadians(latitude)));
            const rightWingLatitude = latitude + (length * 0.2 * Math.sin(headingRad - Cesium.Math.toRadians(angle))) / 110540;

            // viewer.flyTo(entity);
            return {
                positions: Cesium.Cartesian3.fromDegreesArray(
                    [
                        longitude, latitude, // Tip of the arrow
                        leftWingLongitude, leftWingLatitude, // Left wing of the arrow
                        baseLongitude, baseLatitude, // Base of the arrow
                        rightWingLongitude, rightWingLatitude, // Right wing of the arrow
                        longitude, latitude, // Tip of the arrow
                    ]
                ),
                width: 3,
                material: Cesium.Color.RED,
                clampToGround: true,
                distanceDisplayCondition: new Cesium.DistanceDisplayCondition(
                    0.0,          // min distance to show
                    30000000.0      // max distance to show
                )
            };
        }

        // 取得船舶數據並繪製到地圖上
        async function loadShipsData() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const shipname = urlParams.get('shipname') || '';
                const response = await fetch(`/api/ais/history${shipname ? `?shipname=${encodeURIComponent(shipname)}` : ''}`);
                const data = await response.json();
                // console.log(data);

                Object.values(data).forEach(ship => {
                    const position = Cesium.Cartesian3.fromDegrees(ship.lon, ship.lat);

                    // 計算箭頭終點位置
                    const arrowLength = 10 + ship.speed * 100; // 航速影響箭頭長度

                    viewer.entities.add({
                        position: position,
                        polyline: getArrowPolyline(ship.lon, ship.lat, parseFloat(ship.course), arrowLength),
                        label: {
                            text: ship.shipname,
                            font: '14px sans-serif',
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            outlineWidth: 2,
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                            pixelOffset: new Cesium.Cartesian2(0, -32),
                            disableDepthTestDistance: Number.POSITIVE_INFINITY,
                            distanceDisplayCondition: new Cesium.DistanceDisplayCondition(
                                0.0,         // minimum distance to show label
                                500000.0     // maximum distance to show label
                            )
                        },
                        description: `
                            <table>
                                <tr><td>船名:</td><td>${ship.shipname}</td></tr>
                                <tr><td>速度:</td><td>${ship.speed} 節</td></tr>
                                <tr><td>航向:</td><td>${ship.course}°</td></tr>
                                <tr><td>目的地:</td><td>${ship.destination}</td></tr>
                                <tr><td>船舶類型:</td><td>${ship.shiptype}</td></tr>
                                <tr><td>最後更新:</td><td>${new Date(ship.timestamp).toLocaleString()}</td></tr>
                            </table>
                        `
                    });
                });

                // 自動調整視角到所有船舶的位置
                const positions = Object.values(data).map(ship =>
                    Cesium.Cartesian3.fromDegrees(ship.lon, ship.lat)
                );
                viewer.zoomTo(viewer.entities);

            } catch (error) {
                console.error('Error loading ships data:', error);
            }
        }

        // 每分鐘更新一次船舶位置
        loadShipsData();
        setInterval(loadShipsData, 60000);
    </script>
</body>

</html>